
üîç Qu'est-ce que Minishell ?

Minishell est un projet p√©dagogique r√©alis√© dans le cadre du cursus de l'√âcole 42. L'objectif principal est de recr√©er, en langage C, un shell Unix minimaliste ‚Äî c'est-√†-dire un interpr√©teur de commandes similaire √† bash ou zsh, mais limit√© √† un socle de fonctionnalit√©s fondamentales.

    Le shell est l'interface texte par excellence pour interagir avec le syst√®me d'exploitation. Il traduit les instructions utilisateur en appels syst√®mes (syscalls) capables d'ex√©cuter des programmes, manipuler des fichiers, configurer l'environnement logiciel, ou automatiser des suites d'op√©rations.

Ce projet permet de se confronter √† de nombreux aspects essentiels du d√©veloppement syst√®me sous Unix :

    Gestion fine des processus
    Manipulation des entr√©es/sorties
    Parsing lexical complexe
    Gestion des signaux
    Manipulation de l'environnement et de la m√©moire

üéØ Objectifs & Attentes du Projet

Les objectifs p√©dagogiques du projet sont multiples :

    Approfondir la programmation syst√®me en C (fork, execve, dup2, etc.)
    Comprendre la gestion avanc√©e des processus et de la m√©moire sous Unix/Linux
    Mettre en ≈ìuvre et structurer un parser capable de traiter des commandes complexes
    D√©velopper une architecture modulaire et robuste
    G√©rer de mani√®re fiable les erreurs, les cas limites, et les signaux asynchrones
    Respecter une rigueur dans la gestion des ressources syst√®me

üõ† Fonctionnalit√©s D√©velopp√©es
üìã Commandes Internes (Builtins)
Commande 	Fonctionnalit√©
echo 	Affichage de texte avec gestion de l'option -n
cd 	Changement de r√©pertoire avec gestion du home
pwd 	Affichage du r√©pertoire courant actualis√©
export / unset 	Manipulation des variables d'environnement
env 	Affichage de l'environnement courant
exit 	Fermeture du shell avec code de retour
üöÄ Ex√©cution des Commandes Externes

    R√©solution du chemin via la variable $PATH
    Duplication des arguments et fork/exec sur les commandes non internes
    R√©cup√©ration fiable du code de retour

üîÑ Redirections & Pipes

# Exemples de redirections support√©es
command > output.txt    # Redirection de sortie
command >> output.txt   # Redirection en mode append
command < input.txt     # Redirection d'entr√©e
command1 | command2     # Pipe entre deux commandes

    Cr√©ation et cha√Ænage dynamique de pipes (|)
    Gestion des file descriptors pour √©viter les leaks et collisions

üîß Variables d'Environnement et Expansions

    Substitution des variables (ex : echo $USER)
    Support de l'expansion de tilde (~)
    Prise en charge des quotes simples (') et doubles (")
    Gestion des cas d'erreurs (variables non d√©finies, etc.)

üèóÔ∏è Architecture Technique

Le projet est structur√© en deux modules principaux :
1Ô∏è‚É£ Module de Parsing

[Entr√©e utilisateur] ‚Üí [Lexer] ‚Üí [Parser] ‚Üí [AST] ‚Üí [Expansion] ‚Üí [Ex√©cution]

    R√©cup√©ration de la commande : lecture du buffer d'entr√©e
    Analyse lexicale : d√©coupage en tokens (commande, arguments, op√©rateurs...)
    Gestion avanc√©e :
    Quotes (simples/doubles)
    Caract√®res d'√©chappement
    Espaces non significatifs entre quotes
    Erreurs de syntaxe (parenth√®ses non closes, etc.)

2Ô∏è‚É£ Module d'Ex√©cution

    Expansion : Remplacement des variables ($VAR, $?)
    Structure de donn√©es : Encapsulation de chaque commande
    Ex√©cution conditionnelle : Gestion des pipes et redirections

üîç Exemple de Flux d'Ex√©cution

Pour la commande : ls -l | grep test > result.txt

    Parsing en deux structures : ls -l et grep test > result.txt
    Cr√©ation d'un pipe entre les deux
    Redirection de la sortie de grep vers result.txt
    Ex√©cution parall√®le avec synchronisation

